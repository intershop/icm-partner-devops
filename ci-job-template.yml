################################################################################
# Parameters have to be specified by the caller, to customize the pipeline
# for a certain project
################################################################################
parameters:

  # Identifies each job uniquely when ci-job-template.yml is used in a loop. 
  # Can only contain characters, numbers, and underscores.
  # Also used to extend names of files published in extensions.
- name: id
  type: string
  default: ''
  
  # Enables an easy integration with custom jobs. 
  # The parameter will be passed as is to the 'dependsOn' property of the job.
- name: dependsOn
  type: string
  default: ''

  # Enables an easy integration with custom jobs. 
  # The parameter will be passed as is to the 'condition' property of the job.
- name: condition
  type: string
  default: ''

  # Specifies the name of the agent pool.
  # The pool name can't be hardcoded in the pipeline template.
- name: agentPool
  type: string
  default: ''

  # Name of the Service connection to the Docker repository
- name: dockerRepoICMServiceConnection
  type: string
  default: ''

  # Name of Docker repository, containing the ICM-customization product images.
- name: dockerRepoICM
  type: string
  default: ''

  # Name of projects Maven repository.
- name: artifactsFeed
  type: string
  default: ''

  # Name of the service connection to the ACR of the project.
- name: acrServiceConnection
  type: string
  default: ''

  # Repository in ACR including host name.
- name: acr
  type: string
  default: ''

  # Specifies the name of the repository. 
- name: projectPath
  type: string
  default: '$(Build.Repository.Name)'

  # Name of the ci-configuration repositoriy resource.
  # When making adjustments, the 'directoriesConf' parameter must also be adjusted.
- name: envPath
  type: string
  default: 'ci-configuration'

  # Setting required system properties of the JVM
  # When making adjustments, the 'envPath' parameter must also be adjusted.
- name: directoriesConf
  type: string
  default: '-DlicenseDir=$(Pipeline.Workspace)/s/ci-configuration/license -DconfigDir=$(Pipeline.Workspace)/s/ci-configuration/environment'

  # Setting required project properties
- name: repositoriesConf
  type: string
  default: '-PrepoUser=PAT -PrepoPassword=$(System.AccessToken)'

  # Value of the GRADLE_USER_HOME variable
- name: gradleUserHome
  type: string
  default: '$(Pipeline.Workspace)/.gradle'
 
  # Prefix of the GebTest containers
- name: containerPrefix
  type: string
  default: '$(Build.Repository.Name)'

  # Maximum job execution time
- name: jobTimeoutInMinutes
  type: number
  default: 300

  # Specifies whether future jobs should run even if this job fails; defaults to 'false'.
- name: jobContinueOnError
  type: boolean
  default: false

  # Specifies whether all gebTest task should run; defaults to 'true'.
- name: runGebTest
  type: boolean
  default: true

  # gradle gebTest tasks
- name: gebTestTasks
  type: string
  default: 'startSolrCloud startMailSrv startAS startWA startWAA rebuildSearchIndex gebTest'

  # gradle build tasks
- name: gradleBuildTask
  type: string
  default: 'startMSSQL dbPrepare test ishUnitTestReport -x=containerClean'

  # Enable immutable images when created for Git tags.
- name: lockImages
  type: boolean
  default: true

  # Name of template to be executed before all major steps of current job.
- name: preHookTemplate
  type: string
  default: ''
  
  # Name of template to be executed after all major steps of current job.
- name: postHookTemplate
  type: string
  default: ''

  # parameters for code analysis plugin configuration with Gradle v3
  # sonarqube
- name: sonarQubeEnabled
  type: boolean
  default: false

- name: sonarQubePluginVersion
  type: string
  default: '2.6.1'

  # CheckStyle
- name: checkStyleEnabled
  type: boolean
  default: false

  # PMD
- name: pmdEnabled
  type: boolean
  default: false

  # SpotBugs
- name: spotBugsEnabled
  type: boolean
  default: false

- name: spotBugsPluginVersion
  type: string
  default: '4.7.0'

  # Enable this to retag builded Docker images for tags instead of rebuilding them.
- name: retagExistingImages
  type: boolean
  default: false

jobs:
- job: CI${{ parameters.id }}
  pool: '${{ parameters.agentPool }}'
  dependsOn: ${{ parameters.dependsOn }}
  condition: ${{ parameters.condition }}
  continueOnError: ${{ parameters.jobContinueOnError }}
  timeoutInMinutes: ${{ parameters.jobTimeoutInMinutes }}
  workspace:
    clean: all
  variables:
    # See: https://learn.microsoft.com/en-us/azure/devops/pipelines/release/caching?view=azure-devops#gradle
    - name: GRADLE_USER_HOME
      value: ${{ parameters.gradleUserHome }}

  steps:
    # Checkout all repositories
    - checkout: self
      path: s/${{ parameters.projectPath }}
      clean: true
      persistCredentials: true
    - checkout: ${{ parameters.envPath }}
      path: s/${{ parameters.envPath }}
      clean: true

    - ${{ if not(eq(parameters.preHookTemplate, '')) }}:
      - template: ${{ parameters.preHookTemplate }}

    # Check all parameters
    - task: Bash@3
      displayName: Check parameters
      timeoutInMinutes: 5
      inputs:
        targetType: 'inline'
        script: |

          #!/bin/bash

          set -e
      
          if [ -z "${{ parameters.acrServiceConnection }}" ]; then
            echo "##[error] Parameter acrServiceConnection must not be empty!"
            exit 1
          fi
          if [ -z "${{ parameters.artifactsFeed }}" ]; then
            echo "##[error] Parameter artifactsFeed must not be empty!"
            exit 1
          fi
          if [ -z "${{ parameters.dockerRepoICMServiceConnection }}" ]; then
            echo "##[error] Parameter dockerRepoICMServiceConnection must not be empty!"
            exit 1
          fi
          if [ -z "${{ parameters.dockerRepoICM }}" ]; then
            echo "##[error] Parameter dockerRepoICM must not be empty!"
            exit 1
          fi
          if [ -z "${{ parameters.acr }}" ]; then
            echo "##[error] Parameter acr must not be empty!"
            exit 1
          fi
          if [ -z "${{ parameters.projectPath }}" ]; then
            echo "##[error] Parameter projectPath must not be empty!"
            exit 1
          fi
          if [ -z "${{ parameters.envPath }}" ]; then
            echo "##[error] Parameter envPath must not be empty!"
            exit 1
          fi
          if [ -z "${{ parameters.directoriesConf }}" ]; then
            echo "##[error] Parameter directoriesConf must not be empty!"
            exit 1
          fi
          if [ -z "${{ parameters.repositoriesConf }}" ]; then
            echo "##[error] Parameter repositoriesConf must not be empty!"
            exit 1
          fi
          if [ -z "${{ parameters.gradleUserHome }}" ]; then
            echo "##[error] Parameter gradleUserHome must not be empty!"
            exit 1
          fi
          if [ -z "${{ parameters.containerPrefix }}" ]; then
            echo "##[error] Parameter containerPrefix must not be empty!"
            exit 1
          fi
          if [ ! -z "${{ parameters.id }}" ]; then
            if echo "${{ parameters.id }}" | grep -q '[^a-zA-Z0-9_]'; then
              echo "##[error] Parameter id has to consist of characters, numbers and _ only!"
              exit 1
            fi
          fi

          # Removal of the access token from the 'repositoriesConf' parameter
          # Use sed to replace the text between "-PrepoPassword=" and the next space with "XXXX"
          secureRepositoriesConf=$(echo "${{ parameters.repositoriesConf }}" | sed -E 's/(-PrepoPassword=)[^[:space:]]+/\1XXXX/g')

          cat > "$(Pipeline.Workspace)/config${{ parameters.id }}.md" <<EOF

          # Parameters
              id:                             ${{ parameters.id }}
              dockerRepoICMServiceConnection: ${{ parameters.dockerRepoICMServiceConnection }}
              dockerRepoICM:                  ${{ parameters.dockerRepoICM }}
              acrServiceConnection:           ${{ parameters.acrServiceConnection }}
              acr:                            ${{ parameters.acr }}
              artifactsFeed:                  ${{ parameters.artifactsFeed }}
              agentPool:                      ${{ parameters.agentPool }}
              condition:                      ${{ parameters.condition }}
              dependsOn:                      ${{ parameters.dependsOn }}
              projectPath:                    ${{ parameters.projectPath }}
              envPath:                        ${{ parameters.envPath }}
              directoriesConf:                ${{ parameters.directoriesConf }}
              repositoriesConf:               ${secureRepositoriesConf}
              gradleUserHome:                 ${{ parameters.gradleUserHome }}
              containerPrefix:                ${{ parameters.containerPrefix }}
              jobTimeoutInMinutes:            ${{ parameters.jobTimeoutInMinutes }}
              runGebTest:                     ${{ parameters.runGebTest }}
              gebTestTasks:                   ${{ parameters.gebTestTasks }}
              gradleBuildTask:                ${{ parameters.gradleBuildTask }}
              lockImages:                     ${{ parameters.lockImages }}
              preHookTemplate:                ${{ parameters.preHookTemplate }}
              postHookTemplate:               ${{ parameters.postHookTemplate }}
              retagExistingImages:            ${{ parameters.retagExistingImages }}

              # Code Analysis
              sonarQubeRunAnalysis:           ${{ parameters.sonarQubeEnabled }}
              sonarQubeGradlePluginVersion:   ${{ parameters.sonarQubePluginVersion }}
              checkStyleRunAnalysis:          ${{ parameters.checkStyleEnabled }}
              pmdRunAnalysis:                 ${{ parameters.pmdEnabled }}
              spotBugsAnalysis:               ${{ parameters.spotBugsEnabled}}
              spotbugsGradlePluginVersion:    ${{ parameters.spotBugsPluginVersion }}
              
          EOF

    # This task is necessary for the version calculation.
    # Otherwise the git repo is always in detached head and
    # SNAPSHOTS are not longer separeted by their name.
    - task: CmdLine@2
      timeoutInMinutes: 5
      displayName: Checkout $(Build.SourceBranchName)
      inputs:
        workingDirectory: ${{ parameters.projectPath }}
        script: |
          BRANCH="${BUILD_SOURCEBRANCHNAME}"
          if [[ "${BUILD_SOURCEBRANCH}" =~ ^refs/heads.* ]]; then
            BRANCH="${BUILD_SOURCEBRANCH/refs\/heads\//}"
          fi
          git fetch --all
          echo "checkout ${BRANCH}"
          git checkout ${BRANCH}
      condition: and(eq(variables.isVersion, false), ne(variables['Build.SourceBranchName'], 'merge'))

    - task: Docker@2
      displayName: Docker Login - dockerRepoICMServiceConnection
      timeoutInMinutes: 1
      inputs:
        containerRegistry: ${{ parameters.dockerRepoICMServiceConnection }}
        command: 'login'

    - task: Docker@2
      displayName: Docker Login - acrServiceConnection
      timeoutInMinutes: 1
      inputs:
        containerRegistry: ${{ parameters.acrServiceConnection }}
        command: 'login'
    
    - task: Cache@2
      timeoutInMinutes: 5
      inputs:
        key: 'gradle | "$(Agent.OS)" | **/build.gradle.kts'
        restoreKeys: |
          gradle | "$(Agent.OS)"
          gradle
        path: $(GRADLE_USER_HOME)
      displayName: Gradle build cache

    - task: JavaToolInstaller@0
      timeoutInMinutes: 1
      inputs:
        versionSpec: '17'
        jdkArchitectureOption: 'x64'
        jdkSourceOption: 'PreInstalled'

    - task: AzureCLI@2
      timeoutInMinutes: 5
      condition: and(succeeded(), eq('${{ parameters.retagExistingImages }}', true), eq(variables.isVersion, true), startsWith(variables['Build.SourceBranch'], 'refs/tags/'))
      displayName: "Retag existing Images"
      env:
        IMAGE_ARTIFACT_FILE_PATH: $(Agent.TempDirectory)/image/imageProperties.yaml
        REGISTRY: ${{ parameters.acr }}
      inputs:
        azureSubscription: '$(REPO_SERVICE_CONNECTION_ARM)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |

          #!/bin/bash

          # This script pulls a Docker image from a registry, renames/retags it with a target version obtained from Gradle, and pushes it back to the same registry.

          # Log in to Azure DevOps
          echo "$(System.AccessToken)" | az devops login --organization "$(System.CollectionUri)"

          # Get the last successful build ID for this commit
          LAST_SUCCESS_BUILD_ID=$(az pipelines runs list \
            --org $(System.CollectionUri) \
            --project $(System.TeamProjectId) \
            --pipeline-ids $(System.DefinitionId) \
            --query-order FinishTimeDesc \
            --result succeeded \
            --status completed \
            --query "[?sourceVersion=='$(Build.SourceVersion)'].id | [0]" -o tsv
          )

          echo "LAST_SUCCESS_BUILD_ID: ${LAST_SUCCESS_BUILD_ID}"

          # Check if the variable is empty
          if [[ -z "${LAST_SUCCESS_BUILD_ID}" ]]; then
            echo "The variable LAST_SUCCESS_BUILD_ID is empty."
            exit 0
          fi

          # Find the download URL of the artifact
          ARTIFACT_DOWNLOAD_URL=$(az pipelines runs artifact list \
            --run-id "${LAST_SUCCESS_BUILD_ID}" \
            --org "$(System.CollectionUri)" \
            --project "$(System.TeamProjectId)" \
            --query "[?name=='image_artifacts'].resource.downloadUrl" -o tsv)

          echo "ARTIFACT_DOWNLOAD_URL: ${ARTIFACT_DOWNLOAD_URL}"

          # Check if the variable is empty
          if [[ -z "${ARTIFACT_DOWNLOAD_URL}" ]]; then
            echo "The variable ARTIFACT_DOWNLOAD_URL is empty."
            exit 0
          fi

          curl \
            -o $(Agent.TempDirectory)/artifact.zip \
            -L "${ARTIFACT_DOWNLOAD_URL}" \
            -H "Authorization: Bearer $(System.AccessToken)"
          
          unzip -q $(Agent.TempDirectory)/artifact.zip -d $(Agent.TempDirectory)

          # Check if the image artifact file exists
          if [[ ! -f "${IMAGE_ARTIFACT_FILE_PATH}" ]]; then
            echo "File: ${IMAGE_ARTIFACT_FILE_PATH} not exists."
            exit 0
          fi

          IMAGE_TAG=$(yq '.images[0].tag // ""' ${IMAGE_ARTIFACT_FILE_PATH})
          IMAGE_DIGEST=$(yq '.images[0].digest // ""' ${IMAGE_ARTIFACT_FILE_PATH})
          IMAGE_NAME=$(yq '.images[0].name // ""' ${IMAGE_ARTIFACT_FILE_PATH})
          IMAGE_REGISTRY=$(yq '.images[0].registry // ""' ${IMAGE_ARTIFACT_FILE_PATH})

          # Check if IMAGE_TAG, IMAGE_DIGEST, IMAGE_NAME or IMAGE_REGISTRY are empty or null
          if [[ -z "${IMAGE_TAG}" || -z "${IMAGE_DIGEST}" || -z "${IMAGE_NAME}" || -z "${IMAGE_REGISTRY}" ]]; then
            echo "##[error] Invalid image mapping. IMAGE_TAG, IMAGE_DIGEST, IMAGE_NAME or IMAGE_REGISTRY is empty or null."
            exit 0
          fi

          # Check if the image registry matches the expected registry
          if [[ "${IMAGE_REGISTRY}" != "${REGISTRY}" ]]; then
            echo "The strings REGISTRY and IMAGE_REGISTRY are not equal."
            exit 0
          fi

          # Get the image digest from the Azure Container Registry
          ACR_IMAGE_DIGEST=$(az acr repository show \
            -n "${IMAGE_REGISTRY}" \
            --image "${IMAGE_NAME}@${IMAGE_DIGEST}" \
            --query "digest" \
            -o tsv)

          echo "ACR_IMAGE_DIGEST: ${ACR_IMAGE_DIGEST}"

          # Check if the variable is empty
          if [[ -z "${ACR_IMAGE_DIGEST}" ]]; then
            echo "The variable ACR_IMAGE_DIGEST is empty."
            exit 0
          fi

          # Check if the image digest matches the expected digest
          if [[ "${ACR_IMAGE_DIGEST}" != "${IMAGE_DIGEST}" ]]; then
            echo "The strings ACR_IMAGE_DIGEST and IMAGE_DIGEST are not equal."
            exit 0
          fi

          # Change to the project directory
          cd "${{ parameters.projectPath }}"

          # Get the target image version info from Gradle
          TARGET_IMAGE_VERSION_INFO=$(./gradlew showVersion ${{ parameters.directoriesConf }} ${{ parameters.repositoriesConf }} -PbuildID="$(Build.BuildId)")
          echo "TARGET_IMAGE_VERSION_INFO: ${TARGET_IMAGE_VERSION_INFO}"

          # Extract the target version from the output
          TARGET_VERSION=$(echo "$TARGET_IMAGE_VERSION_INFO" | grep -A 1 "GitFlow version is" | tail -n 1 | cut -d' ' -f2- | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          
          echo "TARGET_VERSION: ${TARGET_VERSION}"

          # Check if the variable is empty
          if [[ -z "${TARGET_VERSION}" ]]; then
            echo "The variable TARGET_VERSION is empty."
            exit 0
          fi

          # Pull the Docker image
          docker pull "${IMAGE_REGISTRY}/${IMAGE_NAME}@${IMAGE_DIGEST}" || exit 0

          # Echo the pull success message
          echo "Docker image '${IMAGE_REGISTRY}/${IMAGE_NAME}@${IMAGE_DIGEST}' was successfully pulled."

          # Rename and push the Docker image
          docker tag "${IMAGE_REGISTRY}/${IMAGE_NAME}@${IMAGE_DIGEST}" "${IMAGE_REGISTRY}/${IMAGE_NAME}:${TARGET_VERSION}" || exit 0
          docker push "${IMAGE_REGISTRY}/${IMAGE_NAME}:${TARGET_VERSION}" || exit 0

          # Echo the push success message
          echo "Docker image was successfully pushed to the repository '${IMAGE_REGISTRY}/${IMAGE_NAME}:${TARGET_VERSION}'."

          echo "##vso[task.setvariable variable=imageRetagged;]true"
          echo "##vso[task.setvariable variable=imageRetaggedName;]${IMAGE_REGISTRY}/${IMAGE_NAME}:${TARGET_VERSION}"

    - task: Gradle@3
      timeoutInMinutes: 10
      displayName: Check version
      condition: and(succeeded(), ne(variables.imageRetagged, true))
      continueOnError: true
      inputs:
        cwd: ${{ parameters.projectPath }}
        gradleWrapperFile: ${{ parameters.projectPath }}/gradlew
        gradleOptions: '-Xmx3072m'
        javaHomeOption: 'JDKVersion'
        jdkVersionOption: '17'
        jdkArchitectureOption: 'x64'
        publishJUnitResults: false
        tasks: '-version'

    - task: Gradle@3
      displayName: Clean up container (start)
      condition: and(succeeded(), ne(variables.imageRetagged, true))
      continueOnError: true
      inputs:
        cwd: ${{ parameters.projectPath }}
        gradleWrapperFile: ${{ parameters.projectPath }}/gradlew
        options: '-s -i --max-workers 6 ${{ parameters.directoriesConf }} ${{ parameters.repositoriesConf }} -PbuildID=$(Build.BuildId)'
        gradleOptions: '-Xmx3072m'
        javaHomeOption: 'JDKVersion'
        jdkVersionOption: '17'
        jdkArchitectureOption: 'x64'
        publishJUnitResults: false
        tasks: 'clean containerClean'

    # the task contains the publishing of test results
    - task: Gradle@3
      displayName: Gradle build
      condition: and(succeeded(), ne(variables.imageRetagged, true))
      continueOnError: false
      inputs:
        cwd: ${{ parameters.projectPath }}
        gradleWrapperFile: ${{ parameters.projectPath }}/gradlew
        options: '--refresh-dependencies --scan -s --max-workers 6 -PrunOnCI=true ${{ parameters.directoriesConf }} ${{ parameters.repositoriesConf }} -PbuildID=$(Build.BuildId)'
        gradleOptions: '-Xmx3072m'
        javaHomeOption: 'JDKVersion'
        jdkVersionOption: '17'
        jdkArchitectureOption: 'x64'
        publishJUnitResults: true
        tasks: '${{ parameters.gradleBuildTask }}'
        # Code Analysis
        sonarQubeRunAnalysis: ${{ parameters.sonarQubeEnabled }}
        sonarQubeGradlePluginVersion: '${{ parameters.sonarQubePluginVersion }}'
        checkStyleRunAnalysis: ${{ parameters.checkStyleEnabled }}
        pmdRunAnalysis: ${{ parameters.pmdEnabled }}
        spotBugsAnalysis: ${{ parameters.spotBugsEnabled}}
        spotbugsGradlePluginVersion: '${{ parameters.spotBugsPluginVersion }}'

    - task: Gradle@3
      displayName: Gradle geb tests
      condition: and(succeeded(), eq('${{ parameters.runGebTest }}', 'true'), ne(variables.imageRetagged, true))
      continueOnError: false
      inputs:
        cwd: ${{ parameters.projectPath }}
        gradleWrapperFile: ${{ parameters.projectPath }}/gradlew
        options: '--refresh-dependencies --scan -s --max-workers 6 -PrunOnCI=true ${{ parameters.directoriesConf }} ${{ parameters.repositoriesConf }} -PbuildID=$(Build.BuildId)'
        gradleOptions: '-Xmx3072m'
        javaHomeOption: 'JDKVersion'
        jdkVersionOption: '17'
        jdkArchitectureOption: 'x64'
        publishJUnitResults: true
        tasks: '${{ parameters.gebTestTasks }}'

    - task: CmdLine@2
      displayName: docker write logs geb tests
      condition: and(succeededOrFailed(), eq('${{ parameters.runGebTest }}', 'true'), ne(variables.imageRetagged, true))
      timeoutInMinutes: 5
      inputs:
        workingDirectory: ${{ parameters.projectPath }}
        script: |
          docker ps
          mkdir -p build/geb
          cd build/geb/
          echo log ${{ parameters.containerPrefix }}-wa
          docker logs ${{ parameters.containerPrefix }}-wa &> wa_log.txt
          echo log ${{ parameters.containerPrefix }}-waa
          docker logs ${{ parameters.containerPrefix }}-waa &> waa_log.txt
          echo log ${{ parameters.containerPrefix }}-as
          docker logs ${{ parameters.containerPrefix }}-as &> as_log.txt

    # the task contains the publishing of test results
    - task: Gradle@3
      displayName: Gradle publish artifacts
      condition: and(succeeded(), ne(variables.imageRetagged, true))
      continueOnError: false
      inputs:
        cwd: ${{ parameters.projectPath }}
        gradleWrapperFile: ${{ parameters.projectPath }}/gradlew
        options: '--refresh-dependencies --scan -s --max-workers 6 -PrunOnCI=true ${{ parameters.directoriesConf }} ${{ parameters.repositoriesConf }} -PbuildID=$(Build.BuildId)'
        gradleOptions: '-Xmx3072m'
        javaHomeOption: 'JDKVersion'
        jdkVersionOption: '17'
        jdkArchitectureOption: 'x64'
        publishJUnitResults: true
        tasks: 'buildImages dockerPublish -x=check'

    - task: PublishPipelineArtifact@1
      timeoutInMinutes: 5
      condition: and(succeededOrFailed(), ne(variables.imageRetagged, true))
      displayName: Provide developer files logs for tests
      inputs:
        targetPath: '${{ parameters.projectPath }}/build/ishunitrunner'
        artifactType: 'pipeline'
        artifactName: ishUnitTest_artifacts

    #
    # Post steps
    #
    
    # Generate a build information file and push it as a pipeline artifact.
    - task: Bash@3
      displayName: Create Image Version Overview
      timeoutInMinutes: 5
      env:
        DOCKER_IMAGE_DIRECTORY: ${{ parameters.projectPath }}/build/.docker
      inputs:
        targetType: 'inline'
        script: |

          #!/bin/bash

          set -e

          # This script reads the labels of a Docker image and creates an imageProperty file.

          # Create a temporary folder for storing intermediate files
          TMP_CUSTOM_DIR="$(mktemp -d -p $(Agent.TempDirectory) -t ci-icm-XXXXXXXXXX)"
          IMAGE_PROPERTIES_FILE="${TMP_CUSTOM_DIR}/imageProperties.yaml"

          # Sets IMAGE_NAME based on image tagging conditions or file search in DOCKER_IMAGE_DIRECTORY
          if [[ "$(imageRetagged)" == "true" ]] && [[ -n "$(imageRetaggedName)" ]]; then
            IMAGE_NAME="$(imageRetaggedName)"
          elif [ -n "${DOCKER_IMAGE_DIRECTORY}" ]; then
            # Use 'find' to locate files ending in "-imageId.txt".
            # Sort the list by modification time (newest first).
            # Only return the first file in the list (the newest).
            IMAGE_FILE=$(find "${DOCKER_IMAGE_DIRECTORY}" -name '*-imageId.txt' -type f -printf "%T@ %p\n" | sort -n | tail -1 | cut -f2- -d" ")

            # Check if an image file was found
            if [[ -z "${IMAGE_FILE}" ]]; then
              echo "ERROR: No image file found in ${DOCKER_IMAGE_DIRECTORY}"
              exit 1
            fi
  
            # Check if the image file exists
            if [[ ! -f "${IMAGE_FILE}" ]]; then
              echo "ERROR: ${IMAGE_FILE} does not exist"
              exit 1
            fi
  
            # Extract the image name from the file
            IMAGE_NAME=$(cat "${IMAGE_FILE}" | tr -d '\n\r')
          else
            echo "ERROR: No valid method to obtain the ImageId."
            exit 1
          fi

          echo "IMAGE_NAME: ${IMAGE_NAME}"

          # Check if the image name is valid
          if [[ -z "${IMAGE_NAME}" ]]; then
            echo "ERROR: Image name is empty"
            exit 1
          fi

          # Extract the repository and tag from the image name
          IFS=':' read -r REPOSITORY TAG <<< "${IMAGE_NAME}"

          # Check if the repository and tag are valid
          if [[ -z "${REPOSITORY}" ]] || [[ -z "${TAG}" ]]; then
            echo "ERROR: Invalid image name format in ${IMAGE_FILE}"
            exit 1
          fi

          # Split image name in registry and image base name
          IMAGE_BASE_NAME="${REPOSITORY#*/}"
          REGISTRY="${REPOSITORY%%/*}"

          # Get Image digest
          IMAGE_DIGIST=$(docker image inspect --format='{{index .RepoDigests 0}}' "${IMAGE_NAME}" | cut -d'@' -f2)

          # Generate YAML file
          cat <<EOF > "${IMAGE_PROPERTIES_FILE}"
          images:
            - type: icm-customization
              tag: ${TAG}
              name: ${IMAGE_BASE_NAME}
              registry: ${REGISTRY}
              digest: ${IMAGE_DIGIST}
              buildWith: []
          EOF

          # Read all labels from the Docker image
          IMAGE_LABELS="$(docker inspect -f '{{ json .Config.Labels}}' ${IMAGE_NAME})"

          # Check if the label 'build.with' exists
          if ! echo "${IMAGE_LABELS}" | jq 'has("build.with")' | grep -q true; then
            echo "The 'build.with' label was not found in ${IMAGE_LABELS}."
            exit 1
          fi

          # Read the value of the 'build.with' label
          BUILD_WITH_VALUE=$(echo "${IMAGE_LABELS}" | jq --arg key "build.with" -r '.[$key]')

          # Iterate over the comma-separated list of elements in the 'build.with' label
          IFS=',' read -ra ELEMENTS <<< "$BUILD_WITH_VALUE"
          for ELEMENT in "${ELEMENTS[@]}"; do
            echo "## Element: ${ELEMENT}"

            # Check if the label '<ELEMENT>.version' exists in the Docker image
            ELEMENT_KEY="${ELEMENT}.version"
            if ! echo "${IMAGE_LABELS}" | jq --arg key "${ELEMENT_KEY}" 'has($key)' | grep -q true; then
              echo "The '${ELEMENT_KEY}' label was not found in ${IMAGE_LABELS}."
              exit 1
            fi
            
            # Read the value for the '<ELEMENT>.version' label
            ELEMENT_VALUE=$(echo "${IMAGE_LABELS}" | jq --arg key "${ELEMENT_KEY}" -rc '.[$key]')

            # Check if the ELEMENT_VALUE is not empty
            if [[ -z "${ELEMENT_VALUE}" ]]; then
              echo "The 'ELEMENT_VALUE' variable is empty."
              exit 1
            fi

            # Write the buildWith image to the IMAGE_PROPERTIES_FILE
            ELEMENT_IMAGE_STRING=$(cat <<EOF
            {
              "type": "buildWith",
              "tag": "${ELEMENT_VALUE}",
              "name": "${ELEMENT}",
              "registry": "intershop"
            }
          EOF
          )

            echo "ELEMENT_IMAGE_STRING = $(echo "$ELEMENT_IMAGE_STRING" | jq -rc)"
            ELEMENT_IMAGE_OBJECT="$ELEMENT_IMAGE_STRING" \
            yq -i '.images[0].buildWith += eval(strenv(ELEMENT_IMAGE_OBJECT))' ${IMAGE_PROPERTIES_FILE}
          done
  
          # Print the contents of the imageProperties file
          echo "###### File ${IMAGE_PROPERTIES_FILE} ######"
          cat ${IMAGE_PROPERTIES_FILE}
          echo "###### File end ######"

          # Upload the imageProperties file as an artifact
          echo "##vso[artifact.upload containerfolder=image;artifactname=image_artifacts]${IMAGE_PROPERTIES_FILE}"

          cat >> "$(Pipeline.Workspace)/config${{ parameters.id }}.md" <<EOF

          # Created Docker image
              id:                             ${REPOSITORY}:${TAG}
          EOF

          echo "##vso[task.setvariable variable=tag]${TAG}"
          echo "##vso[task.setvariable variable=imageName]${IMAGE_BASE_NAME}"
          echo "##vso[task.setvariable variable=registry]${REGISTRY}"

    - task: PublishPipelineArtifact@1
      timeoutInMinutes: 5
      displayName: Provide geb test log files
      condition: and(succeededOrFailed(), eq('${{ parameters.runGebTest }}', 'true'), ne(variables.imageRetagged, true))
      inputs:
        targetPath: '${{ parameters.projectPath }}/build/geb'
        artifactType: 'pipeline'
        artifactName: geb_test_log_files${{ parameters.id }}

    - task: PublishPipelineArtifact@1
      timeoutInMinutes: 5
      displayName: Provide developer files logs
      condition: and(succeededOrFailed(), ne(variables.imageRetagged, true))
      inputs:
        targetPath: '${{ parameters.projectPath }}/build/server/logs'
        artifactType: 'pipeline'
        artifactName: build_artifacts${{ parameters.id }}

#    - task: PublishPipelineArtifact@1
#      displayName: Provide developer files Geb tests (sub project my_geb_test)
#      inputs:
#        targetPath: '${{ parameters.projectPath }}/my_geb_test/target/reports/tests/gebTest'
#        artifactType: 'pipeline'
#        artifactName: test_geb_artifacts${{ parameters.id }}
#      condition: succeededOrFailed()

    - task: Gradle@3
      timeoutInMinutes: 10
      displayName: Clean up container (finish)
      inputs:
        cwd: ${{ parameters.projectPath }}
        gradleWrapperFile: ${{ parameters.projectPath }}/gradlew
        options: '-s --max-workers 6 ${{ parameters.directoriesConf }} ${{ parameters.repositoriesConf }} -PbuildID=$(Build.BuildId)'
        gradleOptions: '-Xmx3072m'
        javaHomeOption: 'JDKVersion'
        jdkVersionOption: '17'
        jdkArchitectureOption: 'x64'
        publishJUnitResults: false
        tasks: 'clean containerClean'
      condition: succeededOrFailed()

    # If the parameter lockImages is true and the Build.SourceBranch is a tag, 
    # then the generated Docker images in the ACR will be made non-overwritable and non-deletable.
    - task: AzureCLI@2
      timeoutInMinutes: 5
      condition: and(succeeded(), eq('${{ parameters.lockImages }}', true), startsWith(variables['Build.SourceBranch'], 'refs/tags/'), eq(variables.isVersion, true))
      displayName: "Set image attributes"
      env:
        TAG: $(tag)
        IMAGE_NAME: $(imageName)
        REGISTRY: $(registry)
      inputs:
        azureSubscription: '$(REPO_SERVICE_CONNECTION_ARM)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |

          #!/bin/bash
          set -e

          # Update the image
          az acr repository update \
            --name "${REGISTRY}" \
            --image "${IMAGE_NAME}:${TAG}" \
            --delete-enabled false \
            --write-enabled false

    - ${{ if not(eq(parameters.postHookTemplate, '')) }}:
      - template: ${{ parameters.postHookTemplate }}

    # Clean up all Docker resources generated by the build.        
    - task: Bash@3
      displayName: Docker Cleanup
      timeoutInMinutes: 10
      condition: always()
      inputs:
        targetType: 'inline'
        script: |

          # Stop all containers
          if [[ -n $(docker container ls -a -q) ]]; then docker container stop $(docker container ls -a -q); fi
          # Remove all unused containers, networks, images and volumes.
          docker system prune -a -f --volumes

    # Upload build summary file. The summary will appear on an Extensions tab.       
    - task: Bash@3
      timeoutInMinutes: 5
      condition: always()
      continueOnError: true
      displayName: "Provide pipeline configuration"
      inputs:
        targetType: 'inline'
        script: |
          set -e
          echo "##vso[task.uploadsummary]$(Pipeline.Workspace)/config${{ parameters.id }}.md"
